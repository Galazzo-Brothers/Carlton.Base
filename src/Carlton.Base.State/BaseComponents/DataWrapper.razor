@namespace Carlton.Base.State
@implements IDataWrapper
@implements IDisposable
@typeparam TViewModel
@typeparam TStateEvents where TStateEvents : Enum

@if(ViewModel == null)
{
    //Show Loading SPinner
}
else
{
    <DynamicComponent Type="WrappedComponentType" Parameters="GetParameters()" />
}

@code {
    [Inject]
    private IDataComponent<TViewModel> Component { get; set; }

    [Inject]
    private IMediator Mediatr { get; set; }

    [Inject]
    private IStateStore<TStateEvents> StateStore { get; set; }

    public Object State { get => StateStore; }

    public Type WrappedComponentType { get => Component.GetType(); }

    private TViewModel ViewModel { get; set; }

    private IEnumerable<TStateEvents> StateEvents { get; set; } = new List<TStateEvents> { };

    protected async override Task OnInitializedAsync()
    {
        //Register State Changed Handler
        StateStore.StateChanged += OnStateChanged;

        //Get VM and initalize context for wrapped component
        ViewModel = await GetViewModel();

        //Gather the StateEvents this component should be listening for
        var attributes = (IEnumerable<ObserveStateEventsAttribute<TStateEvents>>)WrappedComponentType.GetCustomAttributes(typeof(ObserveStateEventsAttribute<TStateEvents>));
        StateEvents = attributes.SelectMany(_ => _.StateEvents);

        //Continue initilization
        await base.OnInitializedAsync();
    }

    private async Task<TViewModel> GetViewModel()
    {
        var request = new ViewModelRequest<TViewModel>(this);
        return await Mediatr.Send(request);
    }

    private async Task OnComponentEvent<TCommand>(object sender, TCommand command)
        where TCommand : ICommand
    {
        var commandType = command.GetType();
        var request = Activator.CreateInstance(typeof(CommandRequest<>).MakeGenericType(command.GetType()), this, command);
        await Mediatr.Send(request);
    }

    private async Task OnStateChanged(object sender, TStateEvents stateEvent)
    {
        if(!StateEvents.Contains(stateEvent))
            return;

        ViewModel = await GetViewModel();
        StateHasChanged();
    }

    private Dictionary<string, object> GetParameters()
    {
        var eventCallback = EventCallback.Factory.Create<ICommand>(this, (command) => OnComponentEvent(Component, command));
        return new Dictionary<string, object>
            {
                {"ViewModel", ViewModel},
                {"GetViewModel", async () => await GetViewModel() },
                {"OnComponentEvent", eventCallback}
            };
    }

    public void Dispose()
    {
        StateStore.StateChanged -= OnStateChanged;
    }
}