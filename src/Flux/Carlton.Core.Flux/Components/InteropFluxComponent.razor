@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@namespace Carlton.Core.Flux.Components
@typeparam TViewModel
@typeparam TState
@inherits FluxComponent<TState, TViewModel>
@inject IJSRuntime JsRuntime;
@inject ILogger<InteropFluxComponent<TViewModel, TState>> Logger;


<FluxErrorBoundary TComponent="TViewModel">
    <ChildContent>
        @if (IsLoading)
        {
            @SpinnerContent
        }
        else
        {
            <DynamicComponent Type="WrappedComponentType" Parameters="GetParameters()" />
        }
    </ChildContent>
    <ErrorPrompt Context="error">
        @ErrorContent(error)
    </ErrorPrompt>
</FluxErrorBoundary>


@code {
    private const string Import = "import";

    [Parameter]
    public string JsModule { get; set; }
    [Parameter]
    public string JsFunction { get; set; }
    [Parameter]
    public object[] JsParameters { get; set; }

    protected override async Task<TViewModel> GetViewModel()
    {
        var traceGuid = Guid.NewGuid();
        var vmDisplayName = typeof(TViewModel).GetDisplayName();
        var vmQueryTraceGuid = $"ViewModelJsInteropQuery_{vmDisplayName}_{traceGuid}";
        using (Logger.BeginScope(vmQueryTraceGuid))
        {
            try
            {
                var vmType = typeof(TViewModel).GetDisplayName();
                Logger.ViewModelJsInteropRefreshStarted(vmType);
                await using var module = await JsRuntime.InvokeAsync<IJSObjectReference>(Import, JsModule);
                var result = await module.InvokeAsync<TViewModel>(JsFunction, CancellationToken.None, JsParameters);
                Logger.ViewModelJsInteropRefreshCompleted(vmType);
                return result;
            }
            catch (JSException ex)
            {
                Logger.ViewModelJsInteropRefreshError(ex, typeof(TViewModel).GetDisplayName());
                throw ViewModelFluxException<TState, TViewModel>.JSInteropError(new ViewModelQuery(), ex);
            }
        }
    }
}
