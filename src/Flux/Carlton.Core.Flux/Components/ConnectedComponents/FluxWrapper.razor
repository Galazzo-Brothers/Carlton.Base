@namespace Carlton.Core.Flux.Components
@typeparam TState
@typeparam TViewModel
@implements IDisposable
@inject IConnectedComponent<TViewModel> Component
@inject IViewModelQueryDispatcher<TState> QueryDispatcher
@inject IMutationCommandDispatcher<TState> MutationDispatcher
@inject IFluxStateObserver<TState> StateObserver
@inject ILogger<FluxWrapper<TState, TViewModel>> Logger


@if (IsLoading)
{
    @SpinnerContent
}
else
{
    <DynamicComponent Type="WrappedComponentType" Parameters="GetParameters()" />
}


@code {
    [Parameter]
    public RenderFragment SpinnerContent { get; set; }
    [Parameter]
    public RenderFragment<ErrorPromptModel> ErrorContent { get; set; }

    public Type WrappedComponentType { get => Component.GetType(); }

    public string WrappedComponentDisplayName { get => WrappedComponentType.GetDisplayName(); }

    public TViewModel ViewModel { get; private set; }

    public IEnumerable<string> ObservableStateEvents { get; private set; } = new List<string>();

    protected bool IsLoading { get; set; }

    private string ViewModelDisplayName { get => typeof(TViewModel).GetDisplayName(); }

    protected async override Task OnInitializedAsync()
    {
        var scopes = LogEvents.GetViewModelInitializationLoggingScopes<TViewModel>(Logger);
        using(Logger.BeginScope(scopes))
        {
            //Set IsLoading to true
            IsLoading = true;

            //Register State Changed Handler
            StateObserver.StateChanged += OnStateChanged;

            //Get VM and initialize context for wrapped component
            ViewModel = await GetViewModel();

            //Gather the StateEvents this component should be listening for
            var attributes = WrappedComponentType.GetCustomAttributes<ObserveStateEventsAttribute>();
            ObservableStateEvents = attributes.Select(_ => _.StateEvent);

            //Set IsLoading to false
            IsLoading = false;

            //Continue initialization
            await base.OnInitializedAsync();
        }
    }

    protected virtual async Task<TViewModel> GetViewModel()
    {
        var context = ViewModelQueryContext<TViewModel>.CreateViewModelQueryContext();
        using (Logger.BeginScope(LogEvents.GetViewModelRequestLoggingScopes(Logger, context)))
        {
            try
            {
                var viewmodel = await QueryDispatcher.Dispatch<TViewModel>(Component, context, CancellationToken.None);
                context.MarkAsSucceeded();
                Logger.ViewModelCompleted(context.ViewModelType);
                return viewmodel;
            }
            catch (ViewModelFluxException<TState, TViewModel> ex)
            {
                context.MarkAsErrored(ex);
                Logger.LogError(ex.EventId, ex, ex.Message);
                throw;
            }
        }
    }

    protected async Task OnComponentEvent<TCommand>(object sender, TCommand command)
    {
        var context = new MutationCommandContext<TCommand>(command);
        using (Logger.BeginScope(LogEvents.GetMutationCommandRequestLoggingScopes(Logger, context)))
        {
            try
            {
                await MutationDispatcher.Dispatch(Component, context, CancellationToken.None);
                context.MarkAsSucceeded();
                Logger.MutationCompleted(context.CommandTypeName);
            }
            catch (MutationCommandFluxException<TState, TCommand> ex)
            {
                context.MarkAsErrored(ex);
                Logger.LogError(ex.EventId, ex, ex.Message);
                throw;
            }
        }
    }

    private async Task OnStateChanged(FluxStateChangedEventArgs args)
    {
        var scopes = Logger.BeginScope(LogEvents.GetFluxComponentStateChangedLogginScopes(Logger, args));
        using (scopes)
        {
            //State does not require refresh
            if (!ObservableStateEvents.Contains(args.StateEvent))
                return;

            //Set loading true
            IsLoading = true;

            //Refresh ViewModel
            ViewModel = await GetViewModel();

            //Set loading false
            IsLoading = false;

            //StateHasChanged
            StateHasChanged();
        }
    }

    protected IDictionary<string, object> GetParameters()
    {
        var eventCallback = EventCallback.Factory.Create(this, (command) => OnComponentEvent(Component, command));
        return new Dictionary<string, object>
        {
            { "ViewModel", ViewModel },
            { "GetViewModel", async () => await GetViewModel() },
            { "OnComponentEvent", eventCallback }
        };
    }

    public void Dispose()
    {
        StateObserver.StateChanged -= OnStateChanged;
    }
}
