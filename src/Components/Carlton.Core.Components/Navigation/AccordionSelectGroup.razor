@namespace Carlton.Core.Components.Navigation
@typeparam TValue

@*
    Represents a group of accordion select components.
    TValue: The type of value associated with each item in the select groups.
*@

<div class="accordion-select-group">
    @foreach (var (group, index) in Groups.WithIndex())
    {
        <AccordionSelect TValue="TValue"
                         Title="@group.Name"
                         Items="group.Items"
                         IsExpanded="@group.IsExpanded"
                         SelectedIndex="GetSelectedItemIndex(index)"
                         OnItemExpansionChange="(isExpanded) => HandleGroupExpansionChange(index, isExpanded)"
                         OnItemSelected="(item) => HandleItemSelected(index, item.Index, item.Value)" />
    }
</div>

@code {
    /// <summary>
    /// Gets or sets the collection of select groups to be displayed.
    /// </summary>
    [Parameter]
    public IEnumerable<AccordionSelectGroupModel<TValue>> Groups { get; set; }

    /// <summary>
    /// Event callback invoked when the expansion state of a group changes.
    /// </summary>
    [Parameter]
    public EventCallback<GroupExpansionChangeEventArgs> OnGroupExpansionChange { get; set; }

    /// <summary>
    /// Event callback invoked when an item within a group is selected.
    /// </summary>
    [Parameter]
    public EventCallback<ItemSelectedEventArgs<TValue>> OnItemSelected { get; set; }

    /// <summary>
    /// Gets or sets the index of the currently selected group.
    /// </summary>
    [Parameter]
    public int SelectedGroupIndex { get; set; } = 0;

    /// <summary>
    /// Gets or sets the index of the currently selected item within the group.
    /// </summary>
    [Parameter]
    public int SelectedItemIndex { get; set; } = 0;

    /// <summary>
    /// Gets the value of the currently selected item.
    /// </summary>
    public TValue SelectedValue { get => (SelectedGroupIndex == -1 || SelectedItemIndex == -1) ? default  :
        Groups.ElementAt(SelectedGroupIndex).Items.ElementAt(SelectedItemIndex).Value; }

    protected override void OnInitialized()
    {
        var indicesAreInvalid = SelectedGroupIndex < -1 || //Index less than -1 not allowed
                                 SelectedItemIndex < -1 || //Index less than -1 not allowed
                                 (!Groups.Any() && SelectedGroupIndex != -1) || //Empty groups must have index -1
                                 (Groups.Any() && SelectedGroupIndex > Groups.Count() - 1) || //Non-Empty groups must have index within group count
                                 (Groups.Any() && !Groups.ElementAt(SelectedGroupIndex).Items.Any() && SelectedItemIndex != -1) || //Empty items must have index -1
                                 (Groups.Any() && Groups.ElementAt(SelectedGroupIndex).Items.Any()  && SelectedItemIndex > Groups.ElementAt(SelectedGroupIndex).Items.Count() - 1); //Non-Empty items must have index withi items count

        if (indicesAreInvalid)
            throw new ArgumentException("The provided index parameters are not valid.");

        base.OnInitialized();
    }

    private int GetSelectedItemIndex(int groupIndex)
    {
        return groupIndex == SelectedGroupIndex ? SelectedItemIndex : -1;
    }

    private async Task HandleGroupExpansionChange(int groupIndex, bool isExpanded)
    {
        await OnGroupExpansionChange.InvokeAsync(new GroupExpansionChangeEventArgs(groupIndex, isExpanded));
    }

    private async Task HandleItemSelected(int groupIndex, int itemIndex, TValue value)
    {
        SelectedGroupIndex = groupIndex;
        SelectedItemIndex = itemIndex;
        await OnItemSelected.InvokeAsync(new ItemSelectedEventArgs<TValue>(groupIndex, itemIndex, value));
    }
}