@namespace Carlton.Base.TestBed
@inherits CarltonComponentBase<ComponentViewerViewModel>

<div class="component-viewer">
    <DynamicComponent @ref="CurrentComponent" Type="ViewModel.ComponentType" Parameters="ComponentParameters" />
</div>

@code {
    private DynamicComponent CurrentComponent { get; set; }

    private IDictionary<string, object> ComponentParameters { get; set; } = new Dictionary<string, object>();

    protected override void OnParametersSet()
    {
        ComponentParameters.Clear();

        if(!(typeof(ComponentBase).IsAssignableFrom(ViewModel.ComponentType)))
            throw new InvalidOperationException($"{ViewModel.ComponentType} is not a valid component type.");

        InitComponentParameterDictionary();
        AssignEventCallbacks();
        base.OnParametersSet();
    }

    private void InitComponentParameterDictionary()
    {
        var props = ViewModel.ComponentType
                .GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(prop => Attribute.IsDefined(prop, typeof(ParameterAttribute)))
                .Where(prop => !Attribute.IsDefined(prop, typeof(CascadingParameterAttribute)))
                .Where(prop => prop.PropertyType != typeof(EventCallback) || (prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(EventCallback<>)))
                .Where(prop => prop.PropertyType != typeof(RenderFragment) || (prop.PropertyType.IsGenericType && prop.PropertyType.GetGenericTypeDefinition() == typeof(RenderFragment<>)))
                .ToList();

        foreach(var prop in props)
        {
            var instance = ViewModel.ComponentParameters;
            var type = instance.GetType();
            var instanceProp = type.GetProperty(prop.Name);

            if(instanceProp == null)
                continue;

            var value = instanceProp.GetValue(ViewModel.ComponentParameters);
            if(value != null)
                ComponentParameters.Add(prop.Name, value);
        }
    }

    private void AssignEventCallbacks()
    {
        var eventCallbacks = ViewModel.ComponentType
                 .GetProperties()
                 .Where(_ => _.PropertyType == typeof(EventCallback) || (_.PropertyType.IsGenericType && _.PropertyType.GetGenericTypeDefinition() == typeof(EventCallback<>)))
                 .ToList();

        foreach(var evtCallback in eventCallbacks)
        {
            var isGenericCallback = evtCallback.PropertyType.IsGenericType;
            var lambda = (isGenericCallback) ? CreateGenericEventCallback(evtCallback) : CreateNonGenericEventCallback(evtCallback);
            ComponentParameters.Add(evtCallback.Name, lambda);
        };
    }

    private object CreateGenericEventCallback(PropertyInfo evtCallback)
    {
        var genericTypeParam = evtCallback.PropertyType.GenericTypeArguments.First();
        var lambda = CreateLambda(evtCallback.Name, genericTypeParam);

        var invokeParams = new object[] { CurrentComponent, lambda };

        return GetEvtCallbackFactoryCreateMethodInfo(genericTypeParam)
                           .Invoke(EventCallback.Factory, invokeParams);
    }

    private object CreateNonGenericEventCallback(PropertyInfo evtCallback)
    {
        return EventCallback.Factory.Create(CurrentComponent, 
            () => base.OnComponentEvent.InvokeAsync(new EventRecorded(evtCallback.Name)));
    }

    private Delegate CreateLambda(string evtCallbackName, Type genericTypeParam)
    {
        var nameParamaeter = Expression.Constant(evtCallbackName);
        var objParameter = Expression.Parameter(genericTypeParam);

        var methodInfo = this.GetType()
                             .GetMethod(nameof(RecordEventCallback), BindingFlags.NonPublic | BindingFlags.Instance)
                             .MakeGenericMethod(genericTypeParam);

        var instance = Expression.Constant(this, typeof(ComponentViewer));
        var methodCall = Expression.Call(instance, methodInfo, nameParamaeter, objParameter);
        var lambda = Expression.Lambda(methodCall, objParameter);

        return lambda.Compile();
    }

    private MethodInfo GetEvtCallbackFactoryCreateMethodInfo(Type genericTypeParam)
    {
        var method = typeof(EventCallbackFactory).GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .Where(_ => _.Name == nameof(EventCallbackFactory.Create))
            .Where(_ => _.ContainsGenericParameters)
            .Where(_ => !_.CustomAttributes.Any())
            .First(_ => _.GetParameters().Count() == 2 &&
                        _.GetParameters()[0].ParameterType == typeof(object) &&
                        _.GetParameters()[1].ParameterType.IsGenericType &&
                        _.GetParameters()[1].ParameterType.GetGenericTypeDefinition() == typeof(Action<>));


        var methodInfo = method.MakeGenericMethod(genericTypeParam);
        return methodInfo;
    }

    private void RecordEventCallback<T>(string callbackName, T obj)
    {
        var jsonString = System.Text.Json.JsonSerializer.Serialize(obj);
        base.OnComponentEvent.InvokeAsync(new EventRecorded(callbackName, jsonString));
    }
}



